# Reglas de Proyecto - Brisca Multiplatform

## ğŸš« PROHIBICIÃ“N ABSOLUTA: Strings Hardcodeados

### REGLA CRÃTICA #1: NUNCA usar strings hardcodeados en cÃ³digo UI/Composable

**ESTÃ ESTRICTAMENTE PROHIBIDO:**
- âŒ `Text("Hola mundo")` 
- âŒ `Button(onClick = { }, text = "Actualizar")`
- âŒ `title = "Nueva VersiÃ³n Disponible"`
- âŒ Cualquier string literal dentro de funciones `@Composable`
- âŒ Strings en parÃ¡metros de funciones que renderizan UI
- âŒ Mensajes de error hardcodeados
- âŒ Textos de botones hardcodeados
- âŒ Placeholders hardcodeados
- âŒ Content descriptions hardcodeados

### âœ… OBLIGATORIO: Usar Interfaces de Strings

**SIEMPRE usar interfaces de strings siguiendo ADR-0019:**

1. **Cada pantalla/feature tiene su propia interfaz de strings:**
   ```kotlin
   interface FeatureStrings {
       val title: String
       val buttonText: String
       val errorMessage: String
   }
   ```

2. **Implementaciones por idioma:**
   ```kotlin
   object FeatureStringsEs : FeatureStrings {
       override val title = "TÃ­tulo en EspaÃ±ol"
       override val buttonText = "BotÃ³n en EspaÃ±ol"
       override val errorMessage = "Error en EspaÃ±ol"
   }
   
   object FeatureStringsEn : FeatureStrings {
       override val title = "Title in English"
       override val buttonText = "Button in English"
       override val errorMessage = "Error in English"
   }
   ```

3. **InyecciÃ³n en componentes:**
   ```kotlin
   class FeatureComponent(
       componentContext: ComponentContext,
       private val featureStrings: FeatureStrings // âœ… Inyectado
   ) : ComponentContext by componentContext
   ```

4. **Uso en UI:**
   ```kotlin
   @Composable
   fun FeatureContent(
       component: FeatureComponent,
       strings: FeatureStrings // âœ… Recibido como parÃ¡metro
   ) {
       Text(text = strings.title) // âœ… Usar desde interfaz
       Button(onClick = { }, text = strings.buttonText) // âœ… Usar desde interfaz
   }
   ```

### ğŸ“ UbicaciÃ³n de Interfaces de Strings

- **PatrÃ³n de nombres:** `{FeatureName}Strings.kt`
- **UbicaciÃ³n:** `features/{feature}/domain/strings/` o `features/{feature}/presentation/strings/`
- **Ejemplos:**
  - `features/updateapp/optional/domain/OptionalUpdateStrings.kt`
  - `features/auth/domain/usecase/LoginStrings.kt`
  - `features/maintenance/domain/strings/MaintenanceStrings.kt`

### ğŸ” DetecciÃ³n de Violaciones

**ANTES de escribir cÃ³digo, verificar:**
1. Â¿Este string se muestra en la UI? â†’ DEBE estar en una interfaz
2. Â¿Este string es visible al usuario? â†’ DEBE estar en una interfaz
3. Â¿Este string estÃ¡ en una funciÃ³n `@Composable`? â†’ DEBE estar en una interfaz
4. Â¿Este string estÃ¡ en un parÃ¡metro de componente UI? â†’ DEBE estar en una interfaz

### âš ï¸ Excepciones (MUY LIMITADAS)

**ÃšNICAMENTE se permiten strings hardcodeados en:**
- Logs de debugging (`Log.d("TAG", "debug message")`)
- Nombres de constantes tÃ©cnicas (`const val API_KEY = "key123"`)
- Valores de configuraciÃ³n tÃ©cnica (`BuildConfig.API_URL`)
- Regex patterns (`Regex("pattern")`)
- Keys de mapas tÃ©cnicos (`mapOf("key" to value)`)

**NUNCA en:**
- Textos visibles al usuario
- Mensajes de error mostrados al usuario
- Textos de botones
- TÃ­tulos, subtÃ­tulos, descripciones
- Placeholders de inputs
- Content descriptions de accesibilidad
- Mensajes de validaciÃ³n
- Textos de diÃ¡logos

### ğŸ“ Checklist Antes de Proponer CÃ³digo

Antes de escribir cualquier cÃ³digo con strings, verificar:

- [ ] Â¿Hay strings visibles al usuario? â†’ Crear/actualizar interfaz de strings
- [ ] Â¿La interfaz de strings existe para esta feature? â†’ Verificar en `features/{feature}/domain/strings/`
- [ ] Â¿Los strings estÃ¡n siendo inyectados en el componente? â†’ Verificar inyecciÃ³n de dependencias
- [ ] Â¿Los strings se pasan como parÃ¡metro a funciones Composable? â†’ Verificar firma de funciÃ³n
- [ ] Â¿Todos los textos visibles vienen de la interfaz? â†’ Revisar TODOS los strings literales

### ğŸ¯ Ejemplo Correcto vs Incorrecto

**âŒ INCORRECTO:**
```kotlin
@Composable
fun MyScreen() {
    Text("Nueva VersiÃ³n Disponible") // âŒ PROHIBIDO
    Button(onClick = { }, text = "Actualizar") // âŒ PROHIBIDO
    Text("Error al cargar") // âŒ PROHIBIDO
}
```

**âœ… CORRECTO:**
```kotlin
// 1. Definir interfaz
interface MyScreenStrings {
    val title: String
    val updateButton: String
    val errorMessage: String
}

// 2. ImplementaciÃ³n
object MyScreenStringsEs : MyScreenStrings {
    override val title = "Nueva VersiÃ³n Disponible"
    override val updateButton = "Actualizar"
    override val errorMessage = "Error al cargar"
}

// 3. Inyectar en componente
class MyScreenComponent(
    componentContext: ComponentContext,
    private val strings: MyScreenStrings // âœ… Inyectado
) : ComponentContext by componentContext

// 4. Usar en UI
@Composable
fun MyScreenContent(
    component: MyScreenComponent,
    strings: MyScreenStrings // âœ… Recibido como parÃ¡metro
) {
    Text(text = strings.title) // âœ… Desde interfaz
    Button(onClick = { }, text = strings.updateButton) // âœ… Desde interfaz
    Text(text = strings.errorMessage) // âœ… Desde interfaz
}
```

### ğŸ”§ Cuando Encuentres Strings Hardcodeados

**SI encuentras strings hardcodeados en cÃ³digo existente:**
1. Identificar quÃ© interfaz de strings deberÃ­a contenerlo
2. Agregar el string a la interfaz correspondiente
3. Crear implementaciones para todos los idiomas soportados
4. Refactorizar el cÃ³digo para usar la interfaz
5. Verificar que la interfaz se inyecta correctamente

### ğŸ“š Referencias

- ADR-0019: Interfaces segregadas por pantalla
- `docs/development/cursor-templates.md` - Templates para nuevas pantallas
- Ejemplos existentes en `features/*/domain/strings/` o `features/*/presentation/strings/`

---

## âš ï¸ RECORDATORIO CRÃTICO

**CADA VEZ que escribas cÃ³digo:**
1. Si hay un string visible al usuario â†’ DEBE estar en una interfaz
2. Si estÃ¡s en una funciÃ³n `@Composable` â†’ TODOS los strings DEBEN venir de interfaces
3. Si propones cÃ³digo con strings hardcodeados â†’ EL CÃ“DIGO ESTÃ INCORRECTO

**NO HAY EXCUSAS. NO HAY EXCEPCIONES PARA UI.**
